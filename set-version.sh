#!/usr/bin/env bash
#
# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html
#
# ARG_OPTIONAL_SINGLE([type],[t],[Next version type. Accepted values: major|minor|patch|rc],[minor])
# ARG_HELP([Calculates and prints the next version from the last git tag])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die() {
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}

begins_with_short_option() {
  local first_option all_short_options='rth'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_type="minor"

print_help() {
  printf '%s\n' "Calculates and prints the next version from the last git tag"
  printf 'Usage: %s [-t|--type <arg>] [-h|--help]\n' "$0"
  printf '\t%s\n' "-t, --type: Next version type. Accepted values: major|minor|patch|rc (default: 'minor')"
  printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
  while test $# -gt 0; do
    _key="$1"
    case "$_key" in
    -t | --type)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_type="$2"
      shift
      ;;
    --type=*)
      _arg_type="${_key##--type=}"
      ;;
    -t*)
      _arg_type="${_key##-t}"
      ;;
    -h | --help)
      print_help
      exit 0
      ;;
    -h*)
      print_help
      exit 0
      ;;
    *)
      _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
      ;;
    esac
    shift
  done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

set -o pipefail
set -eE
## keep track of the last executed command
# shellcheck disable=SC2154
trap 'last_command=$current_command; current_command=$BASH_COMMAND' DEBUG
## echo an error message before exiting
# shellcheck disable=SC2154
trap 'printf "\e[31m%s: %s\e[m\n" "\"${last_command}\" failed with exit code" $?.' ERR

RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

printinfo() {
  # shellcheck disable=SC2145
  echo -e "${BLUE}Info: $@${NC}" >&1
}

printerr() {
  # shellcheck disable=SC2145
  echo -e "${RED}Error: $@${NC}" >&1
}

if output=$(git status --porcelain --untracked-files=no) && [ -n "$output" ]; then
  printerr "Working directory has uncommitted changes. Commit or stash your changes before proceeding."
  exit 1
fi

# pull tags before calculating the version
git pull --tags >/dev/null >&1

GIT_TAG="$(git describe --exact-match --tags HEAD 2>&1)" || true

function parseVersion() {
  local tag=""

  if [[ "${GIT_TAG}" == *"No names found, cannot describe anything"* ]]; then
    printinfo "This project does not have any releases."
    tag="v0.1.0"
  elif [[ "${GIT_TAG}" == *"no tag exactly matches"* ]]; then
    tag="$(git describe --tags --abbrev=0)"
  else
    tag="$GIT_TAG"
  fi

  printinfo "found tag '$tag'"

  local regex='[^0-9]*\([0-9]*\)[.]\([0-9]*\)[.]\([0-9]*\)\(-rc\.\([0-9]*\)\)\?'
  #MAJOR
  # shellcheck disable=SC2001
  eval "$1"="$(echo "$tag" | sed -e "s#$regex#\1#")"
  #MINOR
  # shellcheck disable=SC2001
  eval "$2"="$(echo "$tag" | sed -e "s#$regex#\2#")"
  #MINOR
  # shellcheck disable=SC2001
  eval "$3"="$(echo "$tag" | sed -e "s#$regex#\3#")"
  #SPECIAL
  # shellcheck disable=SC2001
  eval "$4"="$(echo "$tag" | sed -e "s#$regex#\5#")"
}

MAJOR=-1
MINOR=-1
PATCH=-1
SPECIAL=-1
VER=""

parseVersion MAJOR MINOR PATCH SPECIAL

printinfo "parsed version elements: $MAJOR | $MINOR | $PATCH | $SPECIAL"

if [[ "$GIT_TAG" != "v$MAJOR.$MINOR.$PATCH" && "$GIT_TAG" != "v$MAJOR.$MINOR.$PATCH-rc.$SPECIAL" ]]; then
  if [[ $_arg_type == "major" ]]; then
    MAJOR=$((MAJOR+1))
    MINOR=0
    PATCH=0
  elif [[ $_arg_type == "minor" ]]; then
    MINOR=$((MINOR+1))
    PATCH=0
  elif [[ $_arg_type == "patch" ]]; then
    PATCH=$((PATCH+1))
  elif [[ $_arg_type == "rc" ]]; then
    if [[ $SPECIAL == "" ]]; then
      MINOR=$((MINOR+1))
      SPECIAL=0
    else
      SPECIAL=$((SPECIAL+1))
    fi
    PATCH=0
  else
    printerr "invalid type option $_arg_type"
    exit 1
  fi
else
  printinfo "HEAD already on latest release $GIT_TAG"
  exit 0
fi

printinfo "next version elements:   $MAJOR | $MINOR | $PATCH | $SPECIAL"

if [[ $_arg_type == "rc" ]]; then
  VER="$MAJOR.$MINOR.$PATCH-rc.$SPECIAL"
  printinfo "Create release candidate $VER"
else
  VER="$MAJOR.$MINOR.$PATCH"
  printinfo "Create release $VER"
fi

# shellcheck disable=SC2086
echo "SEMVER=$VER" >> $GITHUB_OUTPUT || exit 1

# ] <-- needed because of Argbash
